# 斜堆 (Skew Heap)


## 定义

斜堆 (Skew Heap) 是一个保持堆有序的二叉树。

- 仅有一个节点的树是斜堆；
- 两个斜堆合并仍然是斜堆。

## 操作


### 合并

1. 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆；
2. 如果两个斜堆都非空，那么比较两个根结点，将优先级大的根结点的右孩子对应的子堆和另一个堆去合并，合并得到的新子堆的根结点作为新的右孩子。
3. 将当前根结点的左右孩子互换位置。

### 插入

相当于原斜堆与一个点的斜堆合并。

### 删除

移除一个点，合并其左右子堆，用新的堆根节点代替自己。

## 复杂度分析

### top / size / empty

复杂度 $O(1)$。显然，因为都有直接记录。

### merge

均摊复杂度 $O(\log n)$。

证明如下：

假设一共进行 $n$ 次合并，最终得到的斜堆最多包含 $n$ 个节点。

- 定义 **重节点** 为右儿子节点数大于左儿子节点数的节点，反之为 **轻节点**。
- 定义 **右路径** 为一直往右走的路径。
- 定义 **势能函数** $\Phi(i)$ 表示第 $i$ 次合并后，重结点的个数之和。

性质：一条右路径上的轻节点个数一定小于 $\log n$。考虑轻节点的定义，其右子堆大小小于左子堆，也就是说，向轻节点的右儿子走一次，节点数减半，最多 $\log n$ 次结点数就为 $0$ 了。

考虑第 $i$ 次合并，合并堆 $a$ 和堆 $b$。记 $a$ 右路径上轻重节点个数分别为 $l_a,h_a$，记 $b$ 右路径上轻重节点个数分别为 $l_b,h_b$。这次合并的**实际开销**为：

$$
c_i=l_a+h_a+l_b+h_b
$$

考虑一次合并后，在右路径上，原本重节点的右儿子节点数比左儿子大，而合并又是在右儿子上的，在交换左右儿子后，原本重节点**一定**变成了轻节点。轻节点的变化未知，最坏的情况是所有的轻节点都变成了重节点，那么势能函数的变化为：

$$
\Delta\Phi<l_a+l_b-h_a-h_b
$$


**均摊开销** 为：

$$
\begin{aligned}
p_i &= \Delta\Phi+c_i\\
&<2(l_a+l_b)\\
&<2\log n
\end{aligned}
$$

合并 $n$ 次的 **均摊开销** 为:

$$
\sum_{i=1}^{n}p_i=\sum_{i=1}^n c_i+\Phi(n)-\Phi(0)\\
$$

故：

$$
\begin{aligned}
\sum_{i=1}^n c_i&=\sum_{i=1}^n p_i-\Phi(n)+\Phi(0)\\
&<2n\log n + n
\end{aligned}
$$

平均下来每次合并就是 $O(\log n)$ 了。

### push

均摊复杂度 $O(\log n)$。因为相当于原斜堆与一个点的斜堆合并，等价于一次 merge。

### pop

均摊复杂度 $O(\log n)$。因为移除一个点，合并其左右子堆，等价于一次 merge。
